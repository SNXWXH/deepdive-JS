# chap 23

## 📘 제23장: 실행 컨텍스트

---

- *실행 컨텍스트(execution context)**는 자바스크립트 코드가 실행되는 환경을 의미하며, 코드의 실행에 필요한 정보를 모아 관리한다. 이를 통해 변수, 함수, 객체 등의 식별자와 스코프를 효율적으로 관리하며, 코드의 실행 순서를 제어한다.[공부하자+1hong-p+1](https://riley.tistory.com/62?utm_source=chatgpt.com)

---

### 🔹 1. 소스코드의 평가와 실행

자바스크립트 엔진은 코드를 실행하기 전에 두 가지 단계를 거친다

1. **소스코드의 평가**: 코드를 실행하기 전에 변수와 함수의 선언문을 먼저 실행하여, 이를 실행 컨텍스트의 스코프에 등록한다.
2. **소스코드의 실행**: 선언문을 제외한 나머지 코드를 순차적으로 실행하며, 이 과정에서 변수에 값을 할당하거나 함수를 호출한다.

예를 들어, 다음과 같은 코드가 있다고 하자

```jsx
javascript
복사편집
var x;
x = 1;
```

이 경우, 엔진은 먼저 `var x;`를 평가하여 `x`를 스코프에 등록하고 `undefined`로 초기화한다. 그 후, `x = 1;`을 실행하여 `x`에 값을 할당한다.

---

### 🔹 2. 실행 컨텍스트의 역할

실행 컨텍스트는 코드 실행에 필요한 다양한 정보를 관리하며, 주요 역할은 다음과 같다

- **식별자 관리**: 변수, 함수, 클래스 등의 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고, 상태 변화를 지속적으로 관리한다.
- **스코프 체인 형성**: 중첩된 스코프 간의 관계를 형성하여, 상위 스코프로 이동하며 식별자를 검색할 수 있도록 한다.
- **코드 실행 순서 관리**: 함수 호출 등으로 실행 순서가 변경될 때, 이를 관리하고 다시 원래의 실행 위치로 되돌아갈 수 있도록 한다.

이러한 역할을 통해 실행 컨텍스트는 코드의 실행 환경을 구성하고, 코드의 실행 결과를 관리한다.

---

### 🔹 3. 실행 컨텍스트 스택

자바스크립트 엔진은 실행 컨텍스트를 **스택(stack)** 자료구조로 관리한다. 이를 **실행 컨텍스트 스택** 또는 **콜 스택(call stack)**이라고 한다.

예를 들어, 다음과 같은 코드가 있다고 하자:

```jsx
javascript
복사편집
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo(); // 6
```

이 코드의 실행 과정은 다음과 같다.

1. **전역 코드의 평가와 실행**: 전역 실행 컨텍스트가 생성되어 스택에 푸시된다. 이후 전역 코드가 실행되어 `foo` 함수가 호출된다.
2. **`foo` 함수 코드의 평가와 실행**: `foo` 함수의 실행 컨텍스트가 생성되어 스택에 푸시된다. `foo` 함수 내부에서 `bar` 함수가 호출된다.
3. **`bar` 함수 코드의 평가와 실행**: `bar` 함수의 실행 컨텍스트가 생성되어 스택에 푸시된다. `bar` 함수가 실행된 후 종료되면, 해당 실행 컨텍스트는 스택에서 제거된다.
4. **`foo` 함수 코드의 실행 종료**: `foo` 함수의 실행이 종료되면, 해당 실행 컨텍스트도 스택에서 제거된다.
5. **전역 코드의 실행 종료**: 더 이상 실행할 코드가 없으면 전역 실행 컨텍스트도 스택에서 제거된다.

이러한 과정을 통해 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.

---

### 🔹 4. 렉시컬 환경

- *렉시컬 환경(Lexical Environment)**은 식별자와 그에 바인딩된 값을 기록하고, 상위 스코프에 대한 참조를 포함하는 자료구조이다. 실행 컨텍스트는 렉시컬 환경을 통해 스코프와 식별자를 관리한다.

렉시컬 환경은 다음 두 가지 컴포넌트로 구성된다:

1. **환경 레코드(Environment Record)**: 스코프에 포함된 식별자를 등록하고, 등록된 식별자에 바인딩된 값을 관리하는 저장소이다.
2. **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)**: 상위 스코프를 참조하며, 이를 통해 스코프 체인을 형성한다.

이러한 구조를 통해 렉시컬 환경은 중첩된 스코프 간의 관계를 관리하고, 식별자 검색을 수행한다.

### 🔹 5. 실행 컨텍스트의 생성과 식별자 검색 과정

다음 예제를 통해 **실행 컨텍스트 생성 → 스코프 체인 구성 → 식별자 검색 순서**를 단계적으로 설명할 수 있다.

```jsx
javascript
복사편집
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }

  bar(10);
}

foo(20); // 출력 결과: 
```

### 실행 컨텍스트 스택의 흐름

1. **전역 실행 컨텍스트**가 생성되고, `x`, `y`, `foo`가 등록된다.
2. `foo(20)` 호출 → **foo 실행 컨텍스트**가 생성되고 스택에 push된다.
3. `bar(10)` 호출 → **bar 실행 컨텍스트**가 생성되고 스택에 push된다.
4. `console.log(...)` 실행 시 식별자 검색은 다음 순서로 이루어진다:
    - `a`, `b`, `x`, `y`, `z`를 현재 렉시컬 환경에서 찾는다.
    - 없으면 상위 스코프인 `foo`, 더 없으면 전역으로 올라간다.

### 평가 결과

- `a = 20`, `b = 10`, `x = 3`, `y = 4`, `z = 5`
- 출력 결과는 `20 + 10 + 3 + 4 + 5 = 42`가 된다.

---

### 🔹 6. VariableEnvironment vs LexicalEnvironment

실행 컨텍스트 내부에는 원래 두 가지 환경 정보가 존재한다.

| 항목 | 설명 |
| --- | --- |
| **VariableEnvironment** | 선언된 변수/함수를 저장하는 환경 |
| **LexicalEnvironment** | 변수뿐 아니라 스코프 체인을 구성하는 정보까지 포함한 환경 |

→ ES6 이후에는 `VariableEnvironment`가 사실상 `LexicalEnvironment`로 통합되어 사용되며, 따로 구분하지 않는다.

---

### 🔹 7. 실행 컨텍스트와 this 바인딩

실행 컨텍스트는 코드의 유형에 따라 **this 바인딩 방식**을 다르게 처리한다.

| 코드 유형 | this 값 |
| --- | --- |
| 전역 코드 | 전역 객체 (브라우저 환경에서는 window) |
| 일반 함수 | 전역 객체 (strict 모드에서는 undefined) |
| 메서드 | 호출한 객체 |
| 생성자 함수 | 생성된 인스턴스 객체 |
| 화살표 함수 | 상위 스코프의 this를 계승 |

---

### 🔹 8. 정리

| 요소 | 설명 |
| --- | --- |
| 실행 컨텍스트 | 코드 실행 환경이며, 식별자, 스코프, this 등을 추적하고 관리한다. |
| 생성 시점 | 코드가 실행되기 전에 평가 단계에서 생성된다. |
| 실행 컨텍스트 스택 | 실행 순서를 관리하는 구조이며, 함수 호출 시 컨텍스트를 push하고 종료 시 pop한다. |
| 렉시컬 환경 | 변수, 함수 선언을 저장하고, 외부 환경 참조를 통해 스코프 체인을 구성한다. |
| this 바인딩 | 코드 유형에 따라 동적으로 결정되거나 상위 스코프를 계승한다. |